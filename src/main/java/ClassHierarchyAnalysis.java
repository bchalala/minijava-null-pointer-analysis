//
// Generated by JTB 1.3.2
//

import java.util.*;

public class ClassHierarchyAnalysis {

   // Class Hierarchy information
   private HashMap<String,Set<String>> classMethodMap = new HashMap<String, Set<String>>();
   private HashMap<String, String> upClassHierarchy = new HashMap<String, String>();
   private HashMap<String,Set<String>> downClassHierarchy = new HashMap<String, Set<String>>();

   // Variable information
   private HashMap<String, Set<String>> classFields;
   private HashMap<StringPair, Set<String>> methodVariables;
   private HashMap<StringPair, List<String>> methodArguments;

   // Type information
   private HashMap<StringPair, HashMap<String, String>> methodVarTypes = new HashMap<StringPair, HashMap<String, String>>();
   private HashMap<String, HashMap<String, String>> fieldVarTypes = new HashMap<String, HashMap<String, String>>();
   private HashMap<StringPair, String> funRetTypes = new HashMap<StringPair, String>();

   public String getVariableType(StringPair cmPair, String iden) {
      String cname = cmPair.first;
      String mname = cmPair.second;

      HashMap<String, String> typeMap = methodVarTypes.getOrDefault(new StringPair(cname, mname), new HashMap<String, String>());
      if (typeMap.containsKey(iden)) {
        return typeMap.get(iden);
      }

      typeMap = fieldVarTypes.getOrDefault(cname, new HashMap<String, String>());
      if (typeMap.containsKey(iden)) {
        return typeMap.get(iden);
      }

      System.out.println("WARNING: NO TYPE FOUND IN QUERY " + cname + " " + mname + " " + iden);
      return "NO TYPE FOUND!!!";
   }

   public void addFunTyping(StringPair cmPair, String t) {
      funRetTypes.put(cmPair, t);
   }

   public boolean isFunTyped(StringPair cmPair) { return funRetTypes.containsKey(cmPair); }
   public String getFunTyping(StringPair cmPair) { return funRetTypes.get(cmPair); }

   public void addMethodVarTyping(StringPair cmPair, String iden, String t) {
      HashMap<String, String> typeMap = methodVarTypes.getOrDefault(cmPair, new HashMap<String, String>());
      typeMap.put(iden, t);
      methodVarTypes.put(cmPair, typeMap);
   }

   public void addFieldVarTyping(String cname, String iden, String t) {
      HashMap<String, String> typeMap = fieldVarTypes.getOrDefault(cname, new HashMap<String, String>());
      typeMap.put(iden, t);
      fieldVarTypes.put(cname, typeMap);
   }

   public String getClassOfIdentifier(StringPair cmPair, String iden) {
      if (isVariable(cmPair, iden))
        return cmPair.first;

      cmPair.first = getSuperClass(cmPair.first);
      if (cmPair.first == null) {
        return null;
      }

      return getClassOfIdentifier(cmPair, iden);

   }

   public Set<String> getClassFields(String cname) {
      return classFields.getOrDefault(cname, new HashSet<String>());
   }

   public Set<String> getMethodVariables(StringPair cmPair) {
      return methodVariables.getOrDefault(cmPair, new HashSet<String>());
   }

   public List<String> getMethodArguments(StringPair cmPair) {
      return methodArguments.getOrDefault(cmPair, new ArrayList<String>());
   }

   public boolean isVariable(StringPair cmPair, String iden) {
    return (methodVariables.getOrDefault(cmPair, new HashSet()).contains(iden) || 
              classFields.getOrDefault(cmPair.first, new HashSet()).contains(iden) || 
            methodArguments.getOrDefault(cmPair, new ArrayList()).contains(iden));
   }

   public boolean isMethodVariable(StringPair cmPair, String iden) {
      return (methodVariables.getOrDefault(cmPair, new HashSet()).contains(iden) || 
              methodArguments.getOrDefault(cmPair, new ArrayList()).contains(iden));
   }

   public void setCFandMVandMA(HashMap<String, Set<String>> cf, 
                                                HashMap<StringPair, Set<String>> mv,
                                                HashMap<StringPair, List<String>> ma) {
      classFields = cf;
      methodVariables = mv;
      methodArguments = ma;
   }

   public void putClassHierarchyPair(String subC, String superC) {
    upClassHierarchy.put(subC, superC);
    Set<String> subCs = downClassHierarchy.getOrDefault(superC, new HashSet<String>());
    subCs.add(subC);
    downClassHierarchy.put(superC, subCs);
   }

   public void putClassMethod(String c, String m) {
    Set<String> classMethods = classMethodMap.getOrDefault(c, new HashSet<String>());
    classMethods.add(m);
    classMethodMap.put(c, classMethods);
   }

   public String getSuperClass(String c) {
    if (upClassHierarchy.containsKey(c)) {
      return upClassHierarchy.get(c);
    }
    return null;
   }

   public Set<String> getClassesWithMethod(String c, String mname) {
    Set<String> potentialClasses = new HashSet<String>();
    potentialClasses.addAll(subClassWithMethod(c, mname));

    while (c != "") {
      Set<String> methods = classMethodMap.getOrDefault(c, new HashSet<String>());
      if (methods.contains(mname)) {
        potentialClasses.add(c);
        break;
      }
      c = upClassHierarchy.getOrDefault(c, "");
    }

    return potentialClasses;
  }

  private Set<String> subClassWithMethod(String c, String mname) {
    Set<String> ret = new HashSet<String>();

    Set<String> methods = classMethodMap.getOrDefault(c, new HashSet<String>());
    if (methods.contains(mname)) {
      ret.add(c);
    }

    Set<String> subClasses = downClassHierarchy.getOrDefault(c, new HashSet<String>());
    for (String cs : subClasses) {
      if (!cs.equals(c))
        ret.addAll(subClassWithMethod(cs, mname));
    }

    return ret;
  }

  public void print() {
    System.out.println("Class method map\n" + classMethodMap);
    System.out.println(upClassHierarchy);
    System.out.println(downClassHierarchy);
  }

}
